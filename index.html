<!DOCTYPE html>
<html>
  <head>
    <title>Web Array Math API Specification</title>
    <meta http-equiv='Content-Type' content='text/html;charset=utf-8'/>
    <script src='http://www.w3.org/Tools/respec/respec-w3c-common' class='remove' async></script>
    <script class='remove'>
      var respecConfig = {
          // specification status (e.g. unofficial, ED, WD, LCWD, NOTE, etc.). If in doubt use ED.
          specStatus:           "unofficial",

          // the specification's short name, as in http://www.w3.org/TR/short-name/
          shortName:            "webarraymath",

          // if your specification has a subtitle that goes below the main
          // formal title, define it here
          // subtitle   :  "Array math for the Web",

          // if you wish the publication date to be other than today, set this
          // publishDate:  "2009-08-06",

          // if the specification's copyright date is a range of years, specify
          // the start date here:
          // copyrightStart: "2012"

          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          // previousPublishDate:  "1977-03-15",
          // previousMaturity:  "WD",

          // if there a publicly available Editor's Draft, this is the link
          edDraftURI:           "http://opera-mage.github.io/webarraymath/",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // if you want to have extra CSS, append them to this list
          // it is recommended that the respec.css stylesheet be kept
          // ** DOESN'T SEEM TO HAVE ANY EFFECT IN RESPEC v3 **
          extraCSS:             ["http://dev.w3.org/2009/dap/ReSpec.js/css/respec.css"],

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              { name: "Marcus Geelnard",
                company: "Opera Software ASA", companyURL: "http://www.opera.com/" },
          ],

          // authors, add as many as you like.
          // This is optional, uncomment if you have authors as well as editors.
          // only "name" is required. Same format as editors.

          //authors:  [
          //    { name: "Your Name", url: "http://example.org/",
          //      company: "Your Company", companyURL: "http://example.com/" },
          //],

          // name of the WG
          wg:           "W3C Audio Working Group",

          // URI of the public WG page
          wgURI:        "http://www.w3.org/2011/audio/",

          // name (without the @w3c.org) of the public mailing to which comments are due
          wgPublicList: "spec-writers-anonymous",

          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
          wgPatentURI:  "",
      };
    </script>
  </head>
  <body>
    <section id="abstract">
      This specification defines an interface that provides signal processing
      and mathematical functions for 32-bit floating point [[!TYPED-ARRAYS]]
      (<code>Float32Array</code>).
    </section>

    <section class="informative">
      <h2>Introduction</h2>
      <p>
        This specification defines methods that operate on entire arrays rather
        than single elements at a time. The methods are useful for implementing
        performance critical array processing, such as digital signal processing.
      </p>
      <p>
        A fundamental principle of all methods defined in this specification is
        that they operate on existing arrays rather than creating new ones.
        Thus, it is possible to use the methods in applications that are
        sensitive to heap allocation and garbage collection.
      </p>
      <p>
        See <a href="#examples" class="sectionRef"></a> for some
        examples of using the API.
      </p>
    </section>

    <section id="conformance">
    </section>

    <section>
      <h2>Definitions</h2>
      <section>
        <h3>Terms</h3>
        <p>
          The generic term <code>TypedArray</code> is used to indicate any valid
          typed array view type.
        </p>
        <p>
          The term <code>NaN</code> is short for Not a Number, and is a numeric
          value representing an undefined or unrepresentable value.
        </p>
        <p>
          The term <code>RMS</code> is short for Root Mean Square, which is a
          measure of signal energy. For a given signal it is calculated as the
          square root of the arithmetic mean of the squares of the absolute
          values of the signal.
        </p>
        <p>
          The term <code>single precision</code> means binary 32-bit IEEE 754
          floating point.
        </p>
        <p>
          The term <code>double precision</code> means binary 64-bit IEEE 754
          floating point.
        </p>
      </section>
      <section>
        <h3>Pseudo code functions</h3>
        <p>
          Much of this specification is written in terms of mathematical
          expressions. In such expressions, the following pseudo function
          definitions MUST apply:
        </p>
        <dl>
        <dt>clamp(x, x<sub>min</sub>, x<sub>max</sub>)</dt>
        <dd>
          <ul>
            <li>Returns <code>x</code> if <code>x<sub>min</sub></code> &le; <code>x</code> &le; <code>x<sub>max</sub></code>.</li>
            <li>Returns <code>x<sub>min</sub></code> if <code>x</code> &lt; <code>x<sub>min</sub></code>.</li>
            <li>Returns <code>x<sub>max</sub></code> if <code>x</code> &gt; <code>x<sub>max</sub></code>.</li>
            <li>Returns <code>NaN</code> if any of <code>x</code>, <code>x<sub>min</sub></code> or <code>x<sub>max</sub></code> is <code>NaN</code>.</li>
          </ul>
        </dd>
        <dt>modulo(x, y)</dt>
        <dd>
          <p>
            Returns <code>x - floor(x/y) * y</code>.
          </p>
        </dd>
        <dt>sign(x)</dt>
        <dd>
          <ul>
            <li>Returns -1 if <code>x</code> &lt; 0 or <code>x</code> = -0.</li>
            <li>Returns 1 if <code>x</code> &gt; 0 or <code>x</code> = +0.</li>
            <li>Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.</li>
          </ul>
        </dd>
        </dl>
        <p>
          Furthermore, each of the following pseudo functions MUST use the same
          definition as the <code>Math</code> object method with the same name,
          as specified in [[!ECMA-262]], with the exception that single precision
          arithmetic SHOULD be used instead of double precision arithmetic:
          <code>abs</code>,
          <code>acos</code>,
          <code>asin</code>,
          <code>atan</code>,
          <code>atan2</code>,
          <code>ceil</code>,
          <code>cos</code>,
          <code>exp</code>,
          <code>floor</code>,
          <code>log</code>,
          <code>min</code>,
          <code>max</code>,
          <code>pow</code>,
          <code>random</code>,
          <code>round</code>,
          <code>sin</code>,
          <code>sqrt</code>,
          <code>tan</code>.
        </p>
      </section>
      <section>
        <h3>Complex signals</h3>
        <p>
          Complex valued signals are represented as two separate arrays: one
          containing the real part of the signal (suffixed <code>Real</code> in
          the IDL), and one containing the imaginary part of the signal (suffixed
          <code>Imag</code> in the IDL).
        </p>
      </section>
    </section>

    <section>
      <h3>Numerical accuracy</h3>
      <p>
        Unless otherwise noted, numerical computations that are defined in this
        specification MUST meet the following requirements:
      </p>
      <ul>
        <li>
          Computations MUST be carried out using floating point arithmetic with
          at least the same numerical accuracy as single precision floating
          point, subject to the following exception:
          <ul>
            <li>
              Denormalized values may be dealt with in any fashion, including
              rounding them to zero.
            </li>
          </ul>
        </li>
        <li>
          Computational operations MAY be reordered, merged, split or otherwise
          modified, as long as the mathematical meaning is not changed. In other
          words, an alternate computational solution is valid if it yields the
          same result as the solution provided by the specification, when both
          solutions are implemented using infinite numerical accuracy.
        </li>
      </ul>
      <div class="note">
        The rationale is that computational performance is important.
        Conforming clients should be able to utilize any available optimization
        techniques when implementing the API, including (but not limited to)
        using hardware specific instructions and data types that do not fully
        support IEEE 754.
      </div>
    </section>

    <section>
      <h3>Overlapping operation</h3>
      <div class="issue">
        Here we should specify approximately:
        <p>
          Overlapping operations are not allowed except for the special case
          where the destination array is the same as one of the source arrays
          (may differ for different methods).
        </p>
      </div>
      <div class="note">
        The rationale is that an implementation could allow overlapping
        operations for all methods, but it would either require using temporary
        arrays internally, adding a performance hit for some combinations of
        arguments, or an implementation would have to carry double the
        code (more or less) and dynamically switch between forward and backward
        operations, for instance.
      </div>
    </section>

    <section>
      <h2>ArrayMath interface</h2>
      <div class="issue">
        We should probably add offset indexes to most of the methods, to allow
        for operating on only a part of the destination array.
      </div>
      <dl title='interface ArrayMath' class='idl'>
        <!-- Arithmetic operations -->
        <dt>void add (Float32Array dst, double x, Float32Array y)</dt>
        <dd>
          For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dst.length, y.length)</code>,
          the method MUST compute <code>dst[k] = x + y[k]</code>.
        </dd>
        <dt>void add (Float32Array dst, Float32Array x, Float32Array y)</dt>
        <dd>
          For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dst.length, x.length, y.length)</code>,
          the method MUST compute <code>dst[k] = x[k] + y[k]</code>.
        </dd>

        <dt>void sub (Float32Array dst, double x, Float32Array y)</dt>
        <dd>
          For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dst.length, y.length)</code>,
          the method MUST compute <code>dst[k] = x - y[k]</code>.
        </dd>
        <dt>void sub (Float32Array dst, Float32Array x, Float32Array y)</dt>
        <dd>
          For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dst.length, x.length, y.length)</code>,
          the method MUST compute <code>dst[k] = x[k] - y[k]</code>.
        </dd>

        <dt>void mul (Float32Array dst, double x, Float32Array y)</dt>
        <dd>
          For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dst.length, y.length)</code>,
          the method MUST compute <code>dst[k] = x * y[k]</code>.
        </dd>
        <dt>void mul (Float32Array dst, Float32Array x, Float32Array y)</dt>
        <dd>
          For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dst.length, x.length, y.length)</code>,
          the method MUST compute <code>dst[k] = x[k] * y[k]</code>.
        </dd>
        <dt>void mulCplx (Float32Array dstReal, Float32Array dstImag, double xReal, double xImag, Float32Array yReal, Float32Array yImag)</dt>
        <dd>
          <div class="note">
            This method performs multiplication of a complex scalar and a complex array.
          </div>
          <p>
            For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dstReal.length, dstImag.length, yReal.length, yImag.length)</code>,
            the method MUST compute:
          </p>
          <pre class="sh_sourceCode">
dstReal[k] = xReal * yReal[k] - xImag * yImag[k]
dstImag[k] = xReal * yImag[k] + xImag * yReal[k]
          </pre>
        </dd>
        <dt>void mulCplx (Float32Array dstReal, Float32Array dstImag, Float32Array xReal, Float32Array xImag, Float32Array yReal, Float32Array yImag)</dt>
        <dd>
          <div class="note">
            This method performs multiplication of two complex arrays.
          </div>
          <p>
            For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dstReal.length, dstImag.length, xReal.length, xImag.length, yReal.length, yImag.length)</code>,
            the method MUST compute:
          </p>
          <pre class="sh_sourceCode">
dstReal[k] = xReal[k] * yReal[k] - xImag[k] * yImag[k]
dstImag[k] = xReal[k] * yImag[k] + xImag[k] * yReal[k]
          </pre>
        </dd>

        <dt>void div (Float32Array dst, double x, Float32Array y)</dt>
        <dd>
          For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dst.length, y.length)</code>,
          the method MUST compute <code>dst[k] = x / y[k]</code>.
        </dd>
        <dt>void div (Float32Array dst, Float32Array x, Float32Array y)</dt>
        <dd>
          For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dst.length, x.length, y.length)</code>,
          the method MUST compute <code>dst[k] = x[k] / y[k]</code>.
        </dd>
        <dt>void divCplx (Float32Array dstReal, Float32Array dstImag, double xReal, double xImag, Float32Array yReal, Float32Array yImag)</dt>
        <dd>
          <div class="note">
            This method performs division of a complex scalar and a complex array.
          </div>
          <p>
            For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dstReal.length, dstImag.length, yReal.length, yImag.length)</code>,
            the method MUST compute:
          </p>
          <pre class="sh_sourceCode">
denom = yReal[k] * yReal[k] + yImag[k] * yImag[k]
dstReal[k] = (xReal * yReal[k] + xImag * yImag[k]) / denom
dstImag[k] = (xImag * yReal[k] - xReal * yImag[k]) / denom
          </pre>
        </dd>
        <dt>void divCplx (Float32Array dstReal, Float32Array dstImag, Float32Array xReal, Float32Array xImag, Float32Array yReal, Float32Array yImag)</dt>
        <dd>
          <div class="note">
            This method performs division of two complex arrays.
          </div>
          <p>
            For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dstReal.length, dstImag.length, xReal.length, xImag.length, yReal.length, yImag.length)</code>,
            the method MUST compute:
          </p>
          <pre class="sh_sourceCode">
denom = yReal[k] * yReal[k] + yImag[k] * yImag[k]
dstReal[k] = (xReal[k] * yReal[k] + xImag[k] * yImag[k]) / denom
dstImag[k] = (xImag[k] * yReal[k] - xReal[k] * yImag[k]) / denom
          </pre>
        </dd>

        <dt>void madd (Float32Array dst, double x, Float32Array y, Float32Array z)</dt>
        <dd>
          For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dst.length, y.length, z.length)</code>,
          the method MUST compute <code>dst[k] = x * y[k] + z[k]</code>.
        </dd>
        <dt>void madd (Float32Array dst, Float32Array x, Float32Array y, Float32Array z)</dt>
        <dd>
          For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dst.length, x.length, y.length, z.length)</code>,
          the method MUST compute <code>dst[k] = x[k] * y[k] + z[k]</code>.
        </dd>


        <!-- Math operations -->
        <dt>void abs (Float32Array dst, Float32Array x)</dt>
        <dd>
          For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dst.length, x.length)</code>,
          the method MUST compute <code>dst[k] = abs(x[k])</code>.
        </dd>
        <dt>void absCplx (Float32Array dst, Float32Array xReal, Float32Array xImag)</dt>
        <dd>
          <div class="note">
            This method calculates the absolute value (i.e. magnitude) of a
            complex array.
          </div>
          <p>
            For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dst.length, xReal.length, xImag.length)</code>,
            the method MUST compute
            <code>dst[k] = sqrt(xReal[k]<sup>2</sup> + xImag[k]<sup>2</sup>)</code>.
          </p>
        </dd>
        <dt>void acos (Float32Array dst, Float32Array x)</dt>
        <dd>
          For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dst.length, x.length)</code>,
          the method MUST compute <code>dst[k] = acos(x[k])</code>.
        </dd>
        <dt>void asin (Float32Array dst, Float32Array x)</dt>
        <dd>
          For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dst.length, x.length)</code>,
          the method MUST compute <code>dst[k] = asin(x[k])</code>.
        </dd>
        <dt>void atan (Float32Array dst, Float32Array x)</dt>
        <dd>
          For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dst.length, x.length)</code>,
          the method MUST compute <code>dst[k] = atan(x[k])</code>.
        </dd>
        <dt>void atan2 (Float32Array dst, Float32Array y,  Float32Array x)</dt>
        <dd>
          For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dst.length, x.length, y.length)</code>,
          the method MUST compute <code>dst[k] = atan2(y[k], x[k])</code>.
        </dd>
        <dt>void ceil (Float32Array dst, Float32Array x)</dt>
        <dd>
          For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dst.length, x.length)</code>,
          the method MUST compute <code>dst[k] = ceil(x[k])</code>.
        </dd>
        <dt>void cos (Float32Array dst, Float32Array x)</dt>
        <dd>
          For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dst.length, x.length)</code>,
          the method MUST compute <code>dst[k] = cos(x[k])</code>.
        </dd>
        <dt>void exp (Float32Array dst, Float32Array x)</dt>
        <dd>
          For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dst.length, x.length)</code>,
          the method MUST compute <code>dst[k] = exp(x[k])</code>.
        </dd>
        <dt>void floor (Float32Array dst, Float32Array x)</dt>
        <dd>
          For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dst.length, x.length)</code>,
          the method MUST compute <code>dst[k] = floor(x[k])</code>.
        </dd>
        <dt>void log (Float32Array dst, Float32Array x)</dt>
        <dd>
          For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dst.length, x.length)</code>,
          the method MUST compute <code>dst[k] = log(x[k])</code>.
        </dd>
        <dt>double max (Float32Array x)</dt>
        <dd>
          The method MUST return the largest value among all the elements of the array <code>x</code>.
          If the array is empty, it MUST return −∞.
        </dd>
        <dt>double min (Float32Array x)</dt>
        <dd>
          The method MUST return the smallest value among all the elements of the array <code>x</code>.
          If the array is empty, it MUST return ∞.
        </dd>
        <dt>void pow (Float32Array dst, Float32Array x, double y)</dt>
        <dd>
          For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dst.length, x.length)</code>,
          the method MUST compute <code>dst[k] = pow(x[k], y)</code>.
        </dd>
        <dt>void pow (Float32Array dst, Float32Array x, Float32Array y)</dt>
        <dd>
          For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dst.length, x.length, y.length)</code>,
          the method MUST compute <code>dst[k] = pow(x[k], y[k])</code>.
        </dd>
        <dt>void random (Float32Array dst, optional double low=0, optional double high=1)</dt>
        <dd>
          <p>
            For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>dst.length</code>,
            the method MUST compute <code>dst[k] = random() * (high - low) + low</code>.
          </p>
        </dd>
        <dt>void round (Float32Array dst, Float32Array x)</dt>
        <dd>
          For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dst.length, x.length)</code>,
          the method MUST compute <code>dst[k] = round(x[k])</code>.
        </dd>
        <dt>void sin (Float32Array dst, Float32Array x)</dt>
        <dd>
          For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dst.length, x.length)</code>,
          the method MUST compute <code>dst[k] = sin(x[k])</code>.
        </dd>
        <dt>void sqrt (Float32Array dst, Float32Array x)</dt>
        <dd>
          For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dst.length, x.length)</code>,
          the method MUST compute <code>dst[k] = sqrt(x[k])</code>.
        </dd>
        <dt>void tan (Float32Array dst, Float32Array x)</dt>
        <dd>
          For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dst.length, x.length)</code>,
          the method MUST compute <code>dst[k] = tan(x[k])</code>.
        </dd>


        <!-- Other (Math-like) operations -->
        <dt>void clamp (Float32Array dst, Float32Array x, double xMin, double xMax)</dt>
        <dd>
          For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dst.length, x.length)</code>,
          the method MUST compute <code>dst[k] = clamp(x[k], xMin, xMax)</code>.
        </dd>
        <dt>void fract (Float32Array dst, Float32Array x)</dt>
        <dd>
          For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dst.length, x.length)</code>,
          the method MUST compute <code>dst[k] = modulo(x[k], 1)</code>.
        </dd>
        <dt>void fill (Float32Array dst, double value)</dt>
        <dd>
          For each <code>k</code> in the range <code>1</code> &le; <code>k</code> &lt; <code>dst.length</code>,
          the method MUST perform the assignment <code>dst[k] = value</code>.
        </dd>
        <dt>void ramp (Float32Array dst, double first, double last)</dt>
        <dd>
          <p>
            If <code>dst</code> contains at least one element, the method MUST set the first element to <code>first</code>.
          </p>
          <p>
            For each <code>k</code> in the range <code>1</code> &le; <code>k</code> &lt; <code>dst.length</code>,
            the method MUST compute <code>dst[k] = first + k * ((last - first) / (dst.length - 1))</code>.
          </p>
        </dd>
        <dt>void sign (Float32Array dst, Float32Array x)</dt>
        <dd>
          For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dst.length, x.length)</code>,
          the method MUST compute <code>dst[k] = sign(x[k])</code>.
        </dd>
        <dt>double sum (Float32Array x)</dt>
        <dd>
          <p>
            The method MUST return the sum of all the elements of the array <code>x</code>.
            If the array is empty, it MUST return 0 (zero).
          </p>
          <p>
            It is RECOMMENDED that the method is implemented using a summation
            algorithm with an accumulated round-off error growth equal to or
            better than that of pairwise summation.
          </p>
        </dd>


        <!-- Interpolation operations -->
        <dt>void sampleLinear (Float32Array dst, Float32Array x, Float32Array t)</dt>
        <dd>
          <div class="note">
            <p>
              This method implements linear interpolation of the source array
              <code>x</code>. The array is sampled at the points given in the array
              <code>t</code>, and stored in the destination array <code>dst</code>.
            </p>
            <p>
              Values in <code>t</code> are clamped to the valid index range of
              the array <code>x</code>, i.e. <code>[0, x.length)</code>.
            </p>
          </div>
          <p>
            The method MUST perform the following steps:
          </p>
          <ol class="steps">
            <li>
              If the array <code>x</code> is empty (has zero elements), the method
              MUST throw a "<a href="http://www.w3.org/TR/dom/#dom-domexception-not_supported_err">NotSupportedError</a>" exception.
            </li>
            <li>
              The method MUST perform the following operation for each
              <code>k</code> in the range <code>0</code> &le; <code>k</code>
              &lt; <code>min(dst.length, t.length)</code>:
              <pre class="sh_sourceCode">
t' = clamp(t[k], 0, x.length - 1)
idx = floor(t')
w = t' - idx
p1 = x[idx]
p2 = x[min(idx + 1, x.length - 1)]
dst[k] = (1 - w) * p1 + w * p2
              </pre>
            </li>
          </ol>
        </dd>
        <dt>void sampleLinearRepeat (Float32Array dst, Float32Array x, Float32Array t)</dt>
        <dd>
          <div class="note">
            <p>
              This method implements linear interpolation of the source array
              <code>x</code>. The array is sampled at the points given in the array
              <code>t</code>, and stored in the destination array <code>dst</code>.
            </p>
            <p>
              Values in <code>t</code> are taken modulo <code>x.length</code>.
            </p>
          </div>
          <p>
            The method MUST perform the following steps:
          </p>
          <ol class="steps">
            <li>
              If the array <code>x</code> is empty (has zero elements), the method
              MUST throw a "<a href="http://www.w3.org/TR/dom/#dom-domexception-not_supported_err">NotSupportedError</a>" exception.
            </li>
            <li>
              The method MUST perform the following operation for each
              <code>k</code> in the range <code>0</code> &le; <code>k</code>
              &lt; <code>min(dst.length, t.length)</code>:
              <pre class="sh_sourceCode">
t' = modulo(t[k], x.length)
idx = floor(t')
w = t' - idx
p1 = x[idx]
p2 = x[modulo(idx + 1, x.length)]
dst[k] = (1 - w) * p1 + w * p2
              </pre>
            </li>
          </ol>
        </dd>
        <dt>void sampleCubic (Float32Array dst, Float32Array x, Float32Array t)</dt>
        <dd>
          <div class="note">
            <p>
              This method implements cubic Catmull-Rom spline interpolation of the
              source array <code>x</code>. The array is sampled at the points
              given in the array <code>t</code>, and stored in the destination
              array <code>dst</code>.
            </p>
            <p>
              Values in <code>t</code> are clamped to the valid index range of
              the array <code>x</code>, i.e. <code>[0, x.length)</code>.
            </p>
          </div>
          <p>
            The method MUST perform the following steps:
          </p>
          <ol class="steps">
            <li>
              If the array <code>x</code> is empty (has zero elements), the method
              MUST throw a "<a href="http://www.w3.org/TR/dom/#dom-domexception-not_supported_err">NotSupportedError</a>" exception.
            </li>
            <li>
              The method MUST perform the following operation for each
              <code>k</code> in the range <code>0</code> &le; <code>k</code>
              &lt; <code>min(dst.length, t.length)</code>:
              <pre class="sh_sourceCode">
t' = clamp(t[k], 0, x.length - 1)
idx = floor(t')
w = t' - idx
w2 = w*w
w3 = w*w*w
h1 =  2*w3 - 3*w2 + 1
h2 = -2*w3 + 3*w2
h3 = 0.5 * (w3 - 2*w2 + w)
h4 = 0.5 * (w3 -   w2)
p1 = x[max(idx - 1, 0)]
p2 = x[idx]
p3 = x[min(idx + 1, x.length - 1)]
p4 = x[min(idx + 2, x.length - 1)]
dst[k] = h1 * p2 + h2 * p3 + h3 * (p3 - p1) + h4 * (p4 - p2)
              </pre>
            </li>
          </ol>
        </dd>
        <dt>void sampleCubicRepeat (Float32Array dst, Float32Array x, Float32Array t)</dt>
        <dd>
          <div class="note">
            <p>
              This method implements cubic Catmull-Rom spline interpolation of the
              source array <code>x</code>. The array is sampled at the points
              given in the array <code>t</code>, and stored in the destination
              array <code>dst</code>.
            </p>
            <p>
              Values in <code>t</code> are taken modulo <code>x.length</code>.
            </p>
          </div>
          <p>
            The method MUST perform the following steps:
          </p>
          <ol class="steps">
            <li>
              If the array <code>x</code> is empty (has zero elements), the method
              MUST throw a "<a href="http://www.w3.org/TR/dom/#dom-domexception-not_supported_err">NotSupportedError</a>" exception.
            </li>
            <li>
              The method MUST perform the following operation for each
              <code>k</code> in the range <code>0</code> &le; <code>k</code>
              &lt; <code>min(dst.length, t.length)</code>:
              <pre class="sh_sourceCode">
t' = modulo(t[k], x.length)
idx = floor(t')
w = t' - idx
w2 = w*w
w3 = w*w*w
h1 =  2*w3 - 3*w2 + 1
h2 = -2*w3 + 3*w2
h3 = 0.5 * (w3 - 2*w2 + w)
h4 = 0.5 * (w3 -   w2)
p1 = x[modulo(idx - 1, x.length)]
p2 = x[idx]
p3 = x[modulo(idx + 1, x.length)]
p4 = x[modulo(idx + 2, x.length)]
dst[k] = h1 * p2 + h2 * p3 + h3 * (p3 - p1) + h4 * (p4 - p2)
              </pre>
            </li>
          </ol>
        </dd>


        <!-- Data conversion operations -->
        <dt>void pack (TypedArray dst, unsigned long offset, unsigned long stride, Float32Array src1, optional Float32Array src2, optional Float32Array src3, optional Float32Array src4)</dt>
        <dd>
          <div class="note">
            This method packs (interleaves) the unpacked data in <code>src1</code>,
            <code>src2</code>, <code>src3</code> and <code>src4</code>,
            and stores the data interleaved in the <code>dst</code> array,
            which may be of any Typed Array type.
          </div>
          <p>
            This method MUST perform the following steps:
          </p>
          <ol class="steps">
            <li>
              If any of the arguments <code>src2</code>, <code>src3</code>
              or <code>src4</code>, provided that it was passed as an argument,
              has a length that differs from <code>src1.length</code>, the method
              MUST throw a "<a href="http://www.w3.org/TR/dom/#dom-domexception-not_supported_err">NotSupportedError</a>" exception.
            </li>
            <li>
              If <code>stride</code> is less than 1, the method MUST throw a
              "<a href="http://www.w3.org/TR/dom/#dom-domexception-not_supported_err">NotSupportedError</a>" exception.
            </li>
            <li>
              Let <code>dstCount</code> be <code>floor((dst.length - offset) / stride)</code>.
            </li>
            <li>
              For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(dstCount, src1.length)</code>,
              the method MUST perform the following operation, where type conversions
              follow the rules of [[!WEBIDL]]:
              <pre class="sh_sourceCode">
dst[offset + stride*k] = src1[k];
if (src2 argument is defined)
  dst[offset + stride*k + 1] = src2[k];
if (src3 argument is defined)
  dst[offset + stride*k + 2] = src3[k];
if (src4 argument is defined)
  dst[offset + stride*k + 3] = src4[k];
              </pre>
            </li>
          </ol>
        </dd>
        <dt>void unpack (TypedArray src, unsigned long offset, unsigned long stride, Float32Array dst1, optional Float32Array dst2, optional Float32Array dst3, optional Float32Array dst4)</dt>
        <dd>
          <div class="note">
            This method unpacks (de-interleaves) the packed data in <code>src</code>,
            which may be of any Typed Array type, and stores the de-interleaved
            data in the arrays <code>dst1</code>, <code>dst2</code>,
            <code>dst3</code> and <code>dst4</code>.
          </div>
          <p>
            This method MUST perform the following steps:
          </p>
          <ol class="steps">
            <li>
              If any of the arguments <code>dst2</code>, <code>dst3</code>
              or <code>dst4</code>, provided that it was passed as an argument,
              has a length that differs from <code>dst1.length</code>, the method
              MUST throw a "<a href="http://www.w3.org/TR/dom/#dom-domexception-not_supported_err">NotSupportedError</a>" exception.
            </li>
            <li>
              If <code>stride</code> is less than 1, the method MUST throw a
              "<a href="http://www.w3.org/TR/dom/#dom-domexception-not_supported_err">NotSupportedError</a>" exception.
            </li>
            <li>
              Let <code>srcCount</code> be <code>floor((src.length - offset) / stride)</code>.
            </li>
            <li>
              For each <code>k</code> in the range <code>0</code> &le; <code>k</code> &lt; <code>min(srcCount, dst1.length)</code>,
              the method MUST perform the following operation, where type conversions
              follow the rules of [[!WEBIDL]]:
              <pre class="sh_sourceCode">
dst1[k] = src[offset + stride*k];
if (dst2 argument is defined)
  dst2[k] = src[offset + stride*k + 1];
if (dst3 argument is defined)
  dst3[k] = src[offset + stride*k + 2];
if (dst4 argument is defined)
  dst4[k] = src[offset + stride*k + 3];
              </pre>
            </li>
          </ol>
        </dd>

      </dl>
    </section>

    <section>
      <h2>Filter interface</h2>
      <div class="note">
        <p>
          A <code>Filter</code> object implements FIR (finite impulse response)
          and IIR (infinite impulse response) filters of any order.
          The type and order of the filter is defined by setting the
          <code>a</code> and <code>b</code> filter coefficients.
        </p>
        <p>
          If <code>a</code> is an empty array (if it has zero elements),
          the object will effectively implement a convolution between the
          signal <code>x</code> and the impulse response <code>b</code>.
        </p>
        <p>
          A <code>Filter</code> object maintains intra-call state in order to
          facilitate continuous filter operation across several buffers.
        </p>
      </div>
      <div class="issue">
        We should add versions of setA() and setB() that support regular
        ECMAScript arrays. Same thing with the constructor (to be able to pass
        arrays directly instead of using setA() / setB()).
      </div>
      <p>
        A <code>Filter</code> object MUST internally store filter coefficients
        &mdash; hereafter referred to as the arrays <code>a</code> (for the
        recursive coefficients) and <code>b</code> (for the convolution
        coefficients).
      </p>
      <p>
        A <code>Filter</code> object MUST maintain a history state &mdash; hereafter
        referred to as the <em>history</em> &mdash; of the
        input and output signals. This state must keep enough data from previously
        processed input and output signals to make the filtering function well
        defined.
      </p>
      <p>
        At a minimum, the history must contain the <code>b.length - 1</code>
        last processed input samples and the <code>a.length</code> last processed
        output samples from previous calls to the <code>filter()</code>
        method.
      </p>
      <p>
        The <code>Filter()</code> constructor, when invoked, MUST return a newly
        created <code>Filter</code> object. Furthermore, the constructor MUST
        perform the following steps before returning the new <code>Filter</code>
        object:
      </p>
      <ol class="steps">
        <li>
          If <code>bSize</code> is less than 1, a
          "<a href="http://www.w3.org/TR/dom/#dom-domexception-not_supported_err">NotSupportedError</a>"
          exception MUST be thrown.
        </li>
        <li>
          Create the internal array <code>b</code> of length <code>bSize</code>,
          where the first element is assigned the value 1, and the rest of the
          elements are set to 0 (zero).
        </li>
        <li>
          Create the internal array <code>a</code> of length <code>aSize</code>,
          and set all the elements to 0 (zero).
        </li>
        <li>
          Clear the history, as if <code>clearHistory()</code> was called.
        </li>
      </ol>
      <p>
        If there was not enough memory to create the <code>Filter</code>
        object, a
        "<a href="http://www.w3.org/TR/dom/#dom-domexception-not_supported_err">NotSupportedError</a>"
        exception MUST be thrown.
      </p>
      <dl title='[Constructor(unsigned long bSize, optional unsigned long aSize=0)] interface Filter' class='idl'>
        <dt>void filter (Float32Array dst, Float32Array x)</dt>
        <dd>
          <div class="note">
            Applies the configured filter to the array <code>x</code>
            and stores the result in the array <code>dst</code>.
          </div>
          <p>
            The method MUST perform the following steps:
          </p>
          <ol class="steps">
            <li>
              If the length of <code>x</code> differs from the length of
              <code>dst</code>,
              a "<a href="http://www.w3.org/TR/dom/#dom-domexception-not_supported_err">NotSupportedError</a>" exception MUST be thrown.
            </li>
            <li>
              Perform the filtering operation according to the following pseudo
              code:
              <pre class="sh_sourceCode">
for k = 0 to x.length - 1 do
  res = 0;
  for m = 0 to b.length - 1 do
    res = res + b[m] * x[k - m];
  end
  for m = 0 to a.length - 1 do
    res = res - a[m] * dst[k - 1 - m];
  end
  dst[k] = res;
end
              </pre>
              For negative indexes into the arrays <code>x</code> and <code>dst</code>,
              the internal history state from previous calls to this method
              MUST be used.
            </li>
            <li>
              Update the internal history state so that it includes the last
              <code>min(b.length-1, x.length)</code> samples from the array
              <code>x</code> and the last <code>min(a.length, dst.length)</code>
              samples from the array <code>dst</code>.
            </li>
          </ol>
        </dd>
        <dt>void clearHistory ()</dt>
        <dd>
          This method MUST clear the internal history state, so that the next
          <code>filter()</code> call acts as if at least <code>b.length - 1</code> input
          samples with the value 0 (zero) have previously been processed, and
          at least <code>a.length</code> output samples with the value 0 (zero) have
          previously been generated.
        </dd>
        <dt>void setB (Float32Array values)</dt>
        <dd>
          This method MUST set the first <code>min(b.length, values.length)</code>
          coefficients of the internal <code>b</code> array of the filter
          object.
        </dd>
        <dt>void setA (Float32Array values)</dt>
        <dd>
          This method MUST set the first <code>min(a.length, values.length)</code>
          coefficients of the internal <code>a</code> array of the filter
          object.
        </dd>
      </dl>
    </section>

    <section>
      <h2>FFT interface</h2>
      <div class="note">
        An <code>FFT</code> object implements forward and inverse discrete
        Fourier transforms.
      </div>
      <div class="issue">
        The element layout of the frequency domain (forward transform) has
        to be defined.
      </div>
      <div class="issue">
        We should probably add offset indexes to the forward/inverse
        methods, to allow for doing FFT:s of partial arrays without having to
        resort to memory copying or using sub-arrays.
      </div>
      <p>
        The <code>FFT()</code> constructor, when invoked, MUST return a newly
        created <code>FFT</code> object.
      </p>
      <p>
        If the constructor was passed an argument, then the <code>FFT</code>
        object's <code>size</code> property MUST be set to the value of that
        argument. Otherwise, the object's <code>size</code> property MUST be
        set to 256.
      </p>
      <p>
        If a value of less than 1 is passed as the argument to the <code>FFT()</code>
        constructor, a "<a href="http://www.w3.org/TR/dom/#dom-domexception-not_supported_err">NotSupportedError</a>"
        exception MUST be thrown.
      </p>
      <p>
        If there was not enough memory to create the <code>FFT</code>
        object, a
        "<a href="http://www.w3.org/TR/dom/#dom-domexception-not_supported_err">NotSupportedError</a>"
        exception MUST be thrown.
      </p>
      <p>
        The <code>size</code> property tells the number of frequency bins to
        use in subsequent calls to the transformation methods of the
        <code>FFT</code> object: <code>forward</code>, <code>forwardCplx</code>,
        <code>inverse</code> and <code>inverseCplx</code>.
      </p>
      <dl title='[Constructor(optional unsigned long size=256)] interface FFT' class='idl'>
        <dt>void forward (Float32Array dstReal, Float32Array dstImag, Float32Array x)</dt>
        <dd>
          <p>
            This method MUST perform the same operation as if <code>forwardCplx</code>
            was called using the following syntax:
            <code>forwardCplx (dstReal, dstImag, x, dummy)</code>,
            where <code>dummy</code> is a zero-filled <code>Float32Array</code>
            of length <code>size</code>.
          </p>
        </dd>
        <dt>void forwardCplx (Float32Array dstReal, Float32Array dstImag, Float32Array xReal, Float32Array xImag)</dt>
        <dd>
          <p>
            This method MUST compute the forward Fourier transform of
            the first <code>size</code> elements of the complex input signal
            (<code>xReal</code> and <code>xImag</code>), and store the result
            in the first <code>size</code> elements of the complex output signal
            (<code>dstReal</code> and <code>dstImag</code>).
          </p>
          <p>
            The generated output signal MUST be scaled such that the RMS of it
            equals the RMS of the input signal.
          </p>
          <p>
            If any of the arrays <code>xReal</code>, <code>xImag</code>, <code>dstReal</code> and <code>dstImag</code>
            has less than <code>size</code> elements, the method MUST throw a
            "<a href="http://www.w3.org/TR/dom/#dom-domexception-not_supported_err">NotSupportedError</a>" exception.
          </p>
        </dd>
        <dt>void inverse (Float32Array dst, Float32Array xReal, Float32Array xImag)</dt>
        <dd>
          <p>
            This method MUST perform the same operation as if <code>inverseCplx</code>
            was called using the following syntax:
            <code>inverseCplx (dst, dummy, xReal, xImag)</code>,
            where <code>dummy</code> is a <code>Float32Array</code> of length
            <code>size</code>.
          </p>
        </dd>
        <dt>void inverseCplx (Float32Array dstReal, Float32Array dstImag, Float32Array xReal, Float32Array xImag)</dt>
        <dd>
          <p>
            This method MUST compute the inverse Fourier transform of
            the first <code>size</code> elements of the complex input signal
            (<code>xReal</code> and <code>xImag</code>), and store the result
            in the first <code>size</code> elements of the complex output signal
            (<code>dstReal</code> and <code>dstImag</code>).
          </p>
          <p>
            The generated output signal MUST be scaled such that the RMS of it
            equals the RMS of the input signal.
          </p>
          <p>
            If any of the arrays <code>xReal</code>, <code>xImag</code>, <code>dstReal</code> and <code>dstImag</code>
            has less than <code>size</code> elements, the method MUST throw a
            "<a href="http://www.w3.org/TR/dom/#dom-domexception-not_supported_err">NotSupportedError</a>" exception.
          </p>
        </dd>
        <dt>readonly attribute unsigned long size</dt>
        <dd>
          <p>
            Reading this attribute MUST return the size of the Fourier transform,
            i.e. the number of frequency bins that are used during a transform.
          </p>
        </dd>
      </dl>
    </section>

    <section class="appendix informative" id="examples">
      <h2>Examples</h2>
      <p>
        Below are some examples of how to use different interfaces and
        methods provided by this specification. Unless otherwise noted, they
        are written in ECMAScript (with [[!TYPED-ARRAYS]] support).
      </p>
      <p>
        Some of the examples create temporary objects and arrays. In real world
        applications, it is expected that such objects are kept as members of
        long-lived objects in order to minimize heap allocation activity and
        garbage collection.
      </p>
      <p>
         Generate a sine signal with 20 cycles:
      </p>
      <pre class="example">
var y = new Float32Array(1000);
ArrayMath.ramp(y, 0, 2*Math.PI*20);
ArrayMath.sin(y, y);
      </pre>
      <p>
         Generate a low-pass filtered noise signal, using a first order IIR filter:
      </p>
      <pre class="example">
var x = new Float32Array(1000);
ArrayMath.random(x, -1, 1);

var y = new Float32Array(x.length);
var filt = new Filter(1, 1);
filt.setB(new Float32Array([0.01]));
filt.setA(new Float32Array([-0.99]));
filt.filter(y, x);  <em>// y[k] = 0.01 * x[k] + 0.99 * y[k-1]</em>
      </pre>
      <p>
         Calculate the RMS (root mean square) of a signal:
      </p>
      <pre class="example">
function rms (x) {
  var y = new Float32Array(x.length);
  ArrayMath.mul(y, x, x);
  return Math.sqrt(ArrayMath.sum(y) / y.length);
}
      </pre>
      <p>
         Normalize a signal to a given peak amplitude:
      </p>
      <pre class="example">
function normalize (x, magnitude) {
  var peak = Math.max(Math.abs(ArrayMath.max(x)), Math.abs(ArrayMath.min(x)));
  if (peak > 0)
    ArrayMath.mul(x, magnitude / peak, x);
}
      </pre>
      <p>
         Create a Hamming window:
      </p>
      <pre class="example">
function hamming (size) {
  var w = new Float32Array(size);
  ArrayMath.ramp(w, 0, 2*Math.PI);
  ArrayMath.cos(w, w);
  ArrayMath.mul(w, -0.46, w);
  ArrayMath.add(w, 0.54, w);
  return w;
}
      </pre>
      <div class="issue">
        Add more examples, especially examples of using the FFT interface.
      </div>
    </section>
  </body>
</html>
